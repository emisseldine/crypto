# The following a Python implementation of the Hill Cipher
# Note this implementation is with floating points instead of modular arithmetic (the latter is a better implementation)
# Run on any Python compiler such as: https://www.anaconda.com/download
# A free online Python compiler can be accessed at: https://www.programiz.com/python-programming/online-compiler/
import numpy as np

def PadMessage(plaintext, N, n):
    cases = {
        "a": "10", "b": "11", "c": "12", "d": "13", "e": "14", "f": "15",
        "g": "16", "h": "17", "i": "18", "j": "19", "k": "20", "l": "21",
        "m": "22", "n": "23", "o": "24", "p": "25", "q": "26", "r": "27",
        "s": "28", "t": "29", "u": "30", "v": "31", "w": "32", "x": "33",
        "y": "34", "z": "35", "A": "36", "B": "37", "C": "38", "D": "39",
        "E": "40", "F": "41", "G": "42", "H": "43", "I": "44", "J": "45",
        "K": "46", "L": "47", "M": "48", "N": "49", "O": "50", "P": "51",
        "Q": "52", "R": "53", "S": "54", "T": "55", "U": "56", "V": "57",
        "W": "58", "X": "59", "Y": "60", "Z": "61", " ": "62", ".": "63",
        ",": "64", "?": "65", "!": "66", "$": "67", "%": "68", "&": "69",
        "0": "70", "1": "71", "2": "72", "3": "73", "4": "74", "5": "75",
        "6": "76", "7": "77", "8": "78", "9": "79", "+": "80", "-": "81", 
        "*": "82", "/": "83", "=": "84", "^": "85", "@": "86", "#": "87",
        "(": "88", ")": "89", ";": "90", ":": "91", "<": "92", ">": "93",
        "'": "94", "[": "95", "]": "96", "{": "97", "}": "98", "_": "99"
        }
    pm = []
    E = ""
    for i in range(len(plaintext)):
        E += cases.get(plaintext[i])
        if int(E) > N:
            pm.append(int(E[:-2]))
            E = E[-2:]
    pm.append(int(E))
    PM = []
    while len(pm) > n:
        PM.append(pm[:n])
        pm = pm[n:]
    if len(pm) != n:
        pm += [1 for i in range(n-len(pm))]
    PM.append(pm)
    return PM

def DepadMessage(ciphertext):
    cases = {
        "10": "a", "11": "b", "12": "c", "13": "d", "14": "e", "15": "f",
        "16": "g", "17": "h", "18": "i", "19": "j", "20": "k", "21": "l",
        "22": "m", "23": "n", "24": "o", "25": "p", "26": "q", "27": "r",
        "28": "s", "29": "t", "30": "u", "31": "v", "32": "w", "33": "x",
        "34": "y", "35": "z", "36": "A", "37": "B", "38": "C", "39": "D",
        "40": "E", "41": "F", "42": "G", "43": "H", "44": "I", "45": "J",
        "46": "K", "47": "L", "48": "M", "49": "N", "50": "O", "51": "P",
        "52": "Q", "53": "R", "54": "S", "55": "T", "56": "U", "57": "V",
        "58": "W", "59": "X", "60": "Y", "61": "Z", "62": " ", "63": ".",
        "64": ",", "65": "?", "66": "!", "67": "$", "68": "%", "69": "&",
        "70": "0", "71": "1", "72": "2", "73": "3", "74": "4", "75": "5",  
        "76": "6", "77": "7", "78": "8", "79": "9", "80": "+", "81": "-", 
        "82": "*", "83": "/", "84": "=", "85": "^", "86": "@", "87": "#", 
        "88": "(", "89": ")", "90": ",", "91": ":", "92": "<", "93": ">", 
        "94": "'", "95": "[", "96": "]", "97": "{", "98": "}", "99": "_"
        }
    D = ""
    for C in ciphertext:
        for c in C:
            if c != 1:
                D += str(c)
    M = ""
    for i in range(len(D)//2):
        M += cases.get(D[2*i:2*i+2])
    return M

#enter plaintext as a string
#select an nxn nonsingular matrix A and n-vector b as your secret key
#return ciphertext using the Hill cipher c = Ap + b
def HillEncrypt(plaintext, A, b):
    P = np.array(PadMessage(plaintext, 1e7, len(A)))
    return np.array([A @ p + b for p in P])

#enter ciphertext as a matrix
#use your secret key A, b as above
#return plaintext using the Hill cipher p = A^-1(c - b)
def HillDecrypt(ciphertext, A, b):
    D = np.array([np.linalg.inv(A) @ (c - b) for c in ciphertext])
    D = [ [int(round(D[i,j],0)) for j in range(len(D[i]))] for i in range(len(D))]
    return DepadMessage(D)

### Example ###
A = np.array([[1,2],[3,4]])
b = np.array([5,6])
plain = "Linear Algebra is Awesome!"
cipher = HillEncrypt(plain, A, b)
print(cipher)
#print(HillDecrypt(cipher,A,b))

#### Misseldine's Secret Key ######
A = np.array([[ 0.07185715, -0.73403305, -0.9245401,   0.06831321, -0.99356369,  0.11385576,
  -0.1114636,   2.30909435,  0.36192622, -0.11967019],
 [-1.80755781,  1.22593348, -0.34773424,  0.10136277,  0.42606643, -2.25393093,
   0.46025295,  0.8884822,   0.14625532, -0.66134376],
 [ 2.16318097,  1.3983086,  -0.07909026, -0.67269642, -0.23486576,  0.95595673,
  -0.42574108, -0.34537827,  0.43880636, -1.14955975],
 [ 0.98440539,  0.34491878,  0.12644592,  0.47882861, -0.02241699,  0.34776679,
  -0.16761465,  0.11098945, -1.26684221, -1.09423042],
 [ 1.4023592,   0.45170819, -0.33001326,  2.03898531, -1.33414878, -0.11295245,
   1.84079633, -0.73009839, -1.72794381, -0.46256095],
 [ 0.23648501,  0.39544185,  1.45928869,  1.58997185, -0.91045684, -0.28347993,
   0.38404817, -0.61477026, -2.31544097, -0.29597665],
 [-0.95585064, -1.1692586,  -0.67172517,  0.96661565, -1.13900088, -1.22329914,
  -0.29896442,  1.52736112,  1.35261852,  1.75121373],
 [-0.43806009,  1.45023148,  1.53054398, -1.53496971, -1.05904008,  0.15369355,
   1.33089997,  1.94577314, -0.21495214,  0.23519052],
 [-1.57703259, -0.09548134,  0.3858272,   0.78679556, -0.16135646, -2.92701122,
  -1.79814888,  1.25264665, -0.94644234, -1.02401334],
 [-1.00176861,  0.35897352,  2.85150276,  0.58042022, -0.65014164,  0.33789131,
   0.72398736,  1.36855573, -0.20449254,  1.39638702]]) #np.random.normal(size = (n,n))

b = np.array([ 0.88504504,  0.56591143, -1.64601525, -0.48534754,  0.47722304,  1.51061828,
  0.04226098, -1.49431818,  0.82530178, -1.01940259]) #np.random.normal(size = n)

cipher = np.array([[ 797572.3932507201, -589342.47816484, 1197136.4874605502, 465544.88192278997, 582974.89571521, -122128.56482059007, -69904.49053285981, 1649630.8768264202, -1594896.80843794, 1510136.4081454298],
[ -496125.96128213, -717346.2446321601, 93170.41232195999, -579274.8695483102, 407098.37263262033, 301620.2728120499, 1023589.3649087901, 751491.3048643799, -1872642.39451878, 2995130.34237972],
[ -433902.90028784, -306989.9928501399, 67551.80780829013, -224900.4666569001, 821698.2142850301, 667103.82455233, -119723.58709135007, 1852681.43026919, -1965488.8695217003, 2888358.92709333],
[ -36434.52294279995, -520116.46424706007, -38778.78880811005, 32828.23703993001, 953462.49477315, 529427.87872736, 457128.60137259006, 197826.32826105008, -1372349.65900663, 1851223.5513186],
[ 18175.99961969001, -1424422.10660167, 752753.09582755, 232779.31041847996, 13244.31646580015, 442435.66662869, -460278.95248917997, 1445367.1630296002, -1997979.5517550004, 2648284.64466482],
[ 1155977.43982412, -1194587.2796164101, 579379.6451769999, 555884.69353903, 939327.1267996401, 340276.8797806899, 443349.4488914402, 778739.15522135, -1683161.34023841, 1911291.4414772799],
[ -228666.41415854002, -632801.50797052, 603795.9310829499, -115470.09059618998, 273852.44289313006, -307267.11138323, -109314.24927684001, 474831.06912530994, -2067028.3575806804, 1167514.14733521],
[ 16184.234739500049, -141191.13535517012, 233602.57959365984, -34879.11560660001, 1837517.6314697205, 640755.6131704701, 551935.34555019, 936855.51401134, -1914145.1768096501, 2016178.9772504498],
[ 195517.05570030014, -183891.96186919993, -512185.82209066005, -420248.84597185993, 1624195.90081246, 220926.37822699008, 682363.1506857299, 1597564.55016172, -2605135.8364547305, 2144239.4524940997],
[ -288897.54272716, 34343.044336929925, 1453724.2021812901, -132211.80286190004, -805649.0034144701, -1177398.8160497001, -550866.4567193402, 816412.0839912099, -1911805.0319603903, 1085521.1089764498],
[ -647177.4546855199, -360624.05544006015, -360285.0274380601, -219628.35241868004, 957358.1580293899, 385745.8450529499, 107425.52782617998, 390447.6737899101, -2154868.48118472, 2283504.6224337597],
[ -610791.86771722, 810482.8830974299, 444740.22685111, 672466.47963382, 2206698.003283071, 1044311.41640562, -1219185.7108394501, 1084531.43842386, -1685145.9345338203, 1514694.6586004598]])
#print(HillDecrypt(cipher,A,b))
